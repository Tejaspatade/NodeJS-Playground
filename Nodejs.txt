Node.js is a JS runtime run on server side using Google Chrome's V8 Engine.
Used for fast and scalable data driven apps. It is a single threaded, non blocking I/O model,  event driven.


Event driven architecture means any significant action leads to an event emitter emitting an event. Event loop then picks up these events and calls respective callback functions attached to them.

Synchronous code is blocking code as its executed line by line. Every file is treated as a module. Node.js is dependent on V8 and Libuv(C++ based f/w). Libuv provides a thread pool where heavy and time consuming tasks are offloaded so as to not block the single main thread.

---------------------------------------------------------------------

Dependencies can be normal or development/code dependencies. The 2nd type of dependencies are just for development purpose like webpack whereas the 1st type are required for functioning of the app like express framework. For local dependencies, we define scripts in package.json that can be run with npm.

---------------------------------------------------------------------

Streams are used to read/write data piece by piece without completing whole operation meaning without keeping all data in memory. We continously keep on reading chunks of data from a readable stream, every time theres more data available, the data event is emitted.

---------------------------------------------------------------------

require():
1. Resolve & load the module: Check in core modules, developer modules if specified relative path like ./ and finally searched in npm node-modules/
2. Wrapped: wrapped in IIFE where certain objs are passed in. Used to achieve private scope for all modules.
3. Execution.
4. Returns exports
5. Caching.

---------------------------------------------------------------------

Static vs Dynamic vs API:
Static sites have readymade html, css, js files on the server that just need to be fetched for the frontend browser to render. Dyanmic sites usually take data from a DB(mongoDB), generate the website using this dynamic data and some templates and then fetches these over the internet to client(this is called server side rendering where we prep the html, css, js dynamically based on data from db). API based sites only have to get data from DB on the server side, and send this raw data to client side where its used to form the final code to be rendered using frameworks/libraries like React/Vue(here server side consists of only retrieving data from DB and building the API to send the data to client side where its called as consuming API).

API based apps can be used to send this same data to different types of apps and not just browsers. With server side rendereing of dynamic sites, we are stuck with only rendered pages that can be only sent to a browser.

---------------------------------------------------------------------

API & REST: 
Piece of s/w used by another s/w to allow applications to communicate.
REST stands for REpresentational State Transfer. An API following REST principles is called as a RESTful API. 

Principles:
1. Separate API into Logical resources: Resources are objs w/ data associated to them. Any named info is a resource.
2. Expose structured resource-based URLs: Based on all resources identified, each resource should be made available(exposed) using a well structured URL.
3. Use appropriate Http methods to perform actions: Only have resources in endpoint URL and use the HTTP requests to define the type of action to be performed with the resource.
4. Send data as JSON: Use JS Object Notation format when sending/recieving data. Before sending data however, we perform some response formatting like the JSend format.
5. Be stateless: State is any data  about the app that may change over time. All state should be handled on the client side. Server should not be concerned with the state of the app at all.

---------------------------------------------------------------------

Express:
Import Expresss, invoke it express() and store it in an obj. Use the object for different types of requests like GET,POST,DELETE,PUT,PATCH,etc. Finally invoke listen(port no, callback) on object to initialise server.

app.get() -> Get 1 or all resources on url specified. Send no. of results when sending multiple. Check if id is valid for getting only 1 specific item.
app.post() -> Add new item to resource url. Send back the data added as well. 201 code

response.status(code): Status code. 200 -> OK, 201 -> Created, 204 -> No Content, 400 -> Bad Request, 404 -> Error, 500 -> Internal Server Error
response.json(): Send JSON data.

Use the app.route("url") to specify the url, then chain all request types on it that use the same url to avoid repetition.

Note: Include Version for API in url so that newer versions dont break app that use the older version.

Routes are the urls you will use in the request. Route handlers are the callback functions to be invoked for a specific request that gets passed the req and res objects. These req and res objs are what you will use to retrieve any info abt the req and send back the relevant response.

Request Response life cycle starts when client generates a request. The req and res objs are instatntiated that pass thru all the middleware and finally send back the response with the last middleware which is the router.

Middleware: Functions executed before we recieve request and send a response. Usually used to parse body, logging in functionality, setting headers, routing, etc.  They are altogether called middleware stack. Route Handlers that we define are also middlewares but they are just executed for a specific type of request on a specific route & not all of them. These route handlers are always the last one in the middleware stack because they finally send a response. All other middlewares perform certain operations and then invoke the next() function that passes req res obj to next middleware in the stack.

We can add more to the middleware stack using app.use((req, res, next) => {}). But we always need to invoke next() in the end of it otherwise the request response cycle is stuck.

Note: Middlewares shouldn't send a response and invoke next() at the same time, if we want to modify the res in a middleware, instead return the res.send() rather just invoking res.send() because that will mean two different responses are being attempted to be sent which is not valid and throws an error.

express.Route() is used to make an separate router for a single resource. Mounting a router is the process of making this individual router and using it for a specific resource URL. 

A param middleware is used to process requests that are gonna have some paramater passed in like the id of a resource to retrieve that one item. Use route.param("param_name", (req, res, next, val) => {}) to use this middleware for a certain param. 

---------------------------------------------------------------------

Env Variables:
process.env stores all environment variables. Express uses the NODE_ENV var which isnt defined by it. Thus, we need to specify it. We used dotenv library, to specify it in a config.env file and which then gets stored onto the process.env object. dotenv.config({path:'pathname'}) is used to specify the path to the .env file that needs to be stored onto the process.env object.

---------------------------------------------------------------------

Mongoose:
Object Data Modelling library. Code that can interact with mongodb. Middle-man between Node-Express and MongoDB.
mongoose.connect()

1. Schema: Structure with default values, conditionals and validations. Schema uses the native JavaScript DataTypes for type specification. We create a new schema using new mongoose.Schema({
    property: {
        type: datatype,
        required: [true/false, 'Error Message'],
        default: value,
        unique: true/false
    },
})

2. Model: wrapper with interface for querying database. Like classes that are a blueprint. Used to create documents and then perform CRUD on them. mongoose.model('name', schema_obj)
We use schema obj to make a model which is then used to create documents. 

This model can be used to do all sorts of CRUD operations on MongoDB using its methods like:
-> Model.find(): Find by querying all documents. Converts result into array of objects.
-> Model.create({}): Create new Document in collection of the model's name with all the data passed in.
-> Model.findOne({prop:val}): Find one document based on property that matches value given.
-> Model.findById(id): Finds the document matching to id given and returns it.
-> Model.findByIdAndUpdate(id, obj, options): Finds the document matching to id given and updates with properties of obj passed in and takes 3rd argument for optional parameters.
-> Model.findByIdAndDelete(id): Delete obj based on passed id.
-> Model.countDocuments(): Count no. of documents in the collection.
-> Model.sort(): Sort based on field name/s passed to it separated by a whitespace.
-> Model.select(): Select specific fields for each document to be returned in the result rather than the entire object.
-> Model.skip(): Skip no. of documents
-> Model.limit(): Limit no. of documents that would be returned per request.
-> Model.aggregate([]): Create the MongoDb aggregate pipeline which can have the stages as objects in array passed as argument to function.

All such functions return a query and if we await a response on this query it is executed on MongoDB and result is returned. Thus, we can chain a several number of these functions to define complex queries. 
APIs need several features like pagination, field selection, sorting results, filtering results based on field values, etc which can be done by using parameters passed in to req.query from URL. This is perfect example where chaining the mongoose mthods specified above and then finally await on the query to get the resultant documents.

We can make some alias resources available by adding a middleware for this aliased route that would add on all the requirements of this aliased resource point to the request obj so that they can be used when the response is being generated. EX: /top-5-tours can be passed thru a middleware that would add all query parameters to request object to get top 5 tours which will then be sen back as response by the final route handler.

