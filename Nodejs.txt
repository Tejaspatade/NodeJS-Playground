Node.js is a JS runtime run on server side using Google Chrome's V8 Engine.
Used for fast and scalable data driven apps. It is a single threaded, non blocking I/O model,  event driven.


Event driven architecture means any significant action leads to an event emitter emitting an event. Event loop then picks up these events and calls respective callback functions attached to them.

Synchronous code is blocking code as its executed line by line. Every file is treated as a module. Node.js is dependent on V8 and Libuv(C++ based f/w). Libuv provides a thread pool where heavy and time consuming tasks are offloaded so as to not block the single main thread.

---------------------------------------------------------------------

Dependencies can be normal or development/code dependencies. The 2nd type of dependencies are just for development purpose like webpack whereas the 1st type are required for functioning of the app like express framework. For local dependencies, we define scripts in package.json that can be run with npm.

---------------------------------------------------------------------

Streams are used to read/write data piece by piece without completing whole operation meaning without keeping all data in memory. We continously keep on reading chunks of data from a readable stream, every time theres more data available, the data event is emitted.

---------------------------------------------------------------------

require():
1. Resolve & load the module: Check in core modules, developer modules if specified relative path like ./ and finally searched in npm node-modules/
2. Wrapped: wrapped in IIFE where certain objs are passed in. Used to achieve private scope for all modules.
3. Execution.
4. Returns exports
5. Caching.

---------------------------------------------------------------------

Static vs Dynamic vs API:
Static sites have readymade html, css, js files on the server that just need to be fetched for the frontend browser to render. Dyanmic sites usually take data from a DB(mongoDB), generate the website using this dynamic data and some templates and then fetches these over the internet to client(this is called server side rendering where we prep the html, css, js dynamically based on data from db). API based sites only have to get data from DB on the server side, and send this raw data to client side where its used to form the final code to be rendered using frameworks/libraries like React/Vue(here server side consists of only retrieving data from DB and building the API to send the data to client side where its called as consuming API).

API based apps can be used to send this same data to different types of apps and not just browsers. With server side rendereing of dynamic sites, we are stuck with only rendered pages that can be only sent to a browser.

---------------------------------------------------------------------

API & REST: 
Piece of s/w used by another s/w to allow applications to communicate.
REST stands for REpresentational State Transfer. An API following REST principles is called as a RESTful API. 

Principles:
1. Separate API into Logical resources: Resources are objs w/ data associated to them. Any named info is a resource.
2. Expose structured resource-based URLs: Based on all resources identified, each resource should be made available(exposed) using a well structured URL.
3. Use appropriate Http methods to perform actions: Only have resources in endpoint URL and use the HTTP requests to define the type of action to be performed with the resource.
4. Send data as JSON: Use JS Object Notation format when sending/recieving data. Before sending data however, we perform some response formatting like the JSend format.
5. Be stateless: State is any data  about the app that may change over time. All state should be handled on the client side. Server should not be concerned with the state of the app at all.

---------------------------------------------------------------------

Express:
Import Expresss, invoke it express() and store it in an obj. Use the object for different types of requests like GET,POST,DELETE,PUT,PATCH,etc. Finally invoke listen(port no, callback) on object to initialise server.

app.get() -> Get 1 or all resources on url specified. Send no. of results when sending multiple. Check if id is valid for getting only 1 specific item.
app.post() -> Add new item to resource url. Send back the data added as well. 201 code

response.status(code): Status code. 200 -> OK, 201 -> Created, 204 -> No Content, 400 -> Bad Request, 404 -> Error, 500 -> Internal Server Error
response.json(): Send JSON data.

Use the app.route("url") to specify the url, then chain all request types on it that use the same url to avoid repetition.

Note: Include Version for API in url so that newer versions dont break app that use the older version.

Routes are the urls you will use in the request. Route handlers are the callback functions to be invoked for a specific request that gets passed the req and res objects. These req and res objs are what you will use to retrieve any info abt the req and send back the relevant response.

Request Response life cycle starts when client generates a request. The req and res objs are instatntiated that pass thru all the middleware and finally send back the response with the last middleware which is the router.

Middleware: Functions executed before we recieve request and send a response. Usually used to parse body, logging in functionality, setting headers, routing, etc.  They are altogether called middleware stack. Route Handlers that we define are also middlewares but they are just executed for a specific type of request on a specific route & not all of them. These route handlers are always the last one in the middleware stack because they finally send a response. All other middlewares perform certain operations and then invoke the next() function that passes req res obj to next middleware in the stack.

We can add more to the middleware stack using app.use((req, res, next) => {}). But we always need to invoke next() in the end of it otherwise the request response cycle is stuck.

Note: Middlewares shouldn't send a response and invoke next() at the same time, if we want to modify the res in a middleware, instead return the res.send() rather just invoking res.send() because that will mean two different responses are being attempted to be sent which is not valid and throws an error.

express.Route() is used to make an separate router for a single resource. Mounting a router is the process of making this individual router and using it for a specific resource URL. 

A param middleware is used to process requests that are gonna have some paramater passed in like the id of a resource to retrieve that one item. Use route.param("param_name", (req, res, next, val) => {}) to use this middleware for a certain param. 

Error Handling:
operational errors are the ones that are bound to happen and out of dev's control(ex:invalid path accessed by user, failed to connect to server, etc). these are the ones that we will handle in express using a global error handling middleware where all these errors get caught.
Any middleware that passes an argument into the next() function is expected as an error object by express. When passed the error, it skips all middlewares directly to the global error handling middleware.

---------------------------------------------------------------------

Env Variables:
process.env stores all environment variables. Express uses the NODE_ENV var which isnt defined by it. Thus, we need to specify it. We used dotenv library, to specify it in a config.env file and which then gets stored onto the process.env object. dotenv.config({path:'pathname'}) is used to specify the path to the .env file that needs to be stored onto the process.env object.

---------------------------------------------------------------------

Mongoose:
Object Data Modelling library. Code that can interact with mongodb. Middle-man between Node-Express and MongoDB.
mongoose.connect()

1. Schema: Structure with default values, conditionals and validations. Schema uses the native JavaScript DataTypes for type specification. We create a new schema using new mongoose.Schema({
    property: {
        type: datatype,
        required: [true/false, 'Error Message'],
        default: value,
        unique: true/false
    },
})
Schema.virtual(prop_name).get(callback): create a virtual property that isn't stored in DB. It is created and its value is computed everytime we try to retrieve data from DB of this schema. They are used for derived properties to save storage space. If they can just be simply derived from other prpoperties, they dont need to saved into the DB.

Schema can also have middleware just like routes in the Request-Response Life-Cycle do. The middleware can be invoked either before or after a certain type of hook has happened. pre() for before and post() for after. These methods take the hook as an argument and the function to be excuted. These functions are also passed the next function and need to invoke it to continue the cycle. Hooks : find, save, delete, update. These middleware are of 3 types:
-> Document - middleware for document related hooks, save, etc.
-> Query - middleware for query execution related hooks, find, findByIdAndDelete, etc.
-> Aggregate - middleware to be executed before/after aggregation pipeline related operations are performed.

Note: The callback function being passed can't be an arrow function cuz this keyword for the function points to the document in question. this is going to be useful to access properties of that document.

We can define utility functions called instance methods on the schema which will then be available for all documents created using that schema.
Similarly, static methods can also be defined on a schema that can be invoked directly using Model created using that schema. Its exactly how class static methods work. 

2. Model: wrapper with interface for querying database. Like classes that are a blueprint. Used to create documents and then perform CRUD on them. mongoose.model('name', schema_obj)
We use schema obj to make a model which is then used to create documents. 

This model can be used to do all sorts of CRUD operations on MongoDB using its methods like:
-> Model.find(): Find by querying all documents. Converts result into array of objects.
-> Model.create({}): Create new Document in collection of the model's name with all the data passed in.
-> Model.findOne({prop:val}): Find one document based on property that matches value given.
-> Model.findById(id): Finds the document matching to id given and returns it.
-> Model.findByIdAndUpdate(id, obj, options): Finds the document matching to id given and updates with properties of obj passed in and takes 3rd argument for optional parameters.
-> Model.findByIdAndDelete(id): Delete obj based on passed id.
-> Model.countDocuments(): Count no. of documents in the collection.
-> Model.sort(): Sort based on field name/s passed to it separated by a whitespace.
-> Model.select(): Select specific fields for each document to be returned in the result rather than the entire object.
-> Model.skip(): Skip no. of documents
-> Model.limit(): Limit no. of documents that would be returned per request.
-> Model.aggregate([]): Create the MongoDb aggregate pipeline which can have the stages as objects in array passed as argument to function.

All such functions return a query and if we await a response on this query it is executed on MongoDB and result is returned. Thus, we can chain a several number of these functions to define complex queries. 
APIs need several features like pagination, field selection, sorting results, filtering results based on field values, etc which can be done by using parameters passed in to req.query from URL. This is perfect example where chaining the mongoose methods specified above and then finally await on the query to get the resultant documents.

We can make some alias resources available by adding a middleware for this aliased route that would add on all the requirements of this aliased resource point to the request obj so that they can be used when the response is being generated. EX: /top-5-tours can be passed thru a middleware that would add all query parameters to request object to get top 5 tours which will then be sent back as response by the final route handler.

Data Validation:
Data validation has to be done while defining the schema model. All different types of validators can be used to do so. Custom validators can also be used by specifying the validate prop whose value is a function that should return a boolean. 

Note: NDB is an amazing debugger for node.js code.

Data Authentication:
Use password and passwordConfirm fields to confirm password inputted. Encrypt password inputted using bcryptjs library. This can be done using Mongoose middleware so that right after a user password is updated or created, it goes thru this middleware its updated to a hashed version for security.

---------------------------------------------------------------------

JSON Web Tokens(JWT):
JWT is simply a string that is used to represent that a valid user is logged in. When user puts in his credentials and they are identitfied as valid at the backend, a unique JWT is created and sent back which is then stored in localStorage/cookies for the user. This acts as a token that the user is logged in. Whenever the user tries to acces some user specific resource, this JWT is used to check whether data should be sent back from the backend and if yes, which user's specific data. JWT acts as a passport that gets you into specific regions where only registered users have access. This helps keep the database stateless, meaning unknown to the no of users that are logged in. This is one of the principles of RESTful APIs. There can be any no of users logged in and the server doesn't need to know about it. It just checks for valid/invalid JWTs when restricted resources are accessed.

A JWT conmprises of 3 parts:
-> Header: metadata of the token.
-> Payload: actual info to be exchanged.
--> Signature: made using header, payload and secret from server. Used to verify the JWT and implement authentication.

Header & Payload fields are encoded fields; meaning anyone can decode and interpret them. The signature however, is encrypted thus no unauthorized person can interpret it.
The signature coming from a JWT is compare with a test JWT at the server-side creted using the header, payload and secret to make sure the request is coming from a signed in user. We delegate this functionality to the jsonwebtoken npm package.

A logged in user sends the token in the authorization header of the request. The Value for this header has to be in format of: Bearer token_here. This token indicates that the user trying to acce the resource is logged in. Thus, if absent, the resource can be denied access and asked to log in first. This is Authentication of the user while logging in.

Authorization is a whole different thing wherein we want a specific type of user to access certain protected resource. This is another security measure.

Note: Only store encrypted sensitive information in the DB like passwords, reset tokens, etc. If ever in case the DB gets breached, they aren't compromised.

A signed in user should always have the token being sent in the request header in the Uthorization field in the format Bearer token. Absence of this indidcates user isnt logged in. this token then can be validated, authenticated and verified if user is logged in or not.

---------------------------------------------------------------------

Security
-> Compromised Database: Encrypt Passwords with salts & hash(bcryptjs), Encrypt Password Reset Tokens(crypto) 
-> Brute Force Attacks: Make login requests slower(bcrypt), Rate limiting, Restrict Maximum Login Attempts
-> Cross Site Scripting Attacks: Store JWT in HTTPOnlyCookie(never in localStorage), Sanitize User Inputs, Set special HTTP Headers.
-> Denial Of Service Attacks: Rate Limiting, Limit Body payload size, avoid complex regexes.
-> Use HTTPS, Create reset tokens randomly & set expiry, Deny access to JWT after password change, Dont upload config to Git.

Rate limiting: express-rate-limit package. Invoke function, pass in options and pass in as middleware.
HTTP Header: helmet package. Adds all secuity related headers essential to safeguard requests that the browser can understand and act on.
Data Sanitization: express-mongo-sanitize package for NSQL Query Injection Attacks. Removes $ and . from all json strings being parsed so that the queries injected wont work. xss-clean package for cross-site scripting attacks. Scans HTML for malicious code.
Parameter pollution: hpp package. Removes duplicate params passed in.

---------------------------------------------------------------------

Data Modelling: understand the different type of unstructured data to be dealt with coming from a real world scenario, structurise it in a logical data model.

1) Identify relationships between data: 3 types-
-> 1:1 - a movie can have only 1 name
-> 1:Many - 1:Few - movie can win few awards ; 1:Many - movie can have many reviews; 1:Ton - app can have tons of logins
-> Many:Many - many movies can many actors and vice versa.

2) Referencing(normalization)/Embedding(denormalization): Referenicing means to separate concerns with different data in diff documents, which in turn are then referenced using their ids. This referencing can be of child or parent type. This is how data is stored in SQL. But in NOSQL we have option of storing all related data altogether in one place. This is embedding. With embedding, accessing all related data can be done in single query however, accessing embedded data on its own is not possible. On the other hand, in referencing, accessing individual data is easier but to access all referenced data requires more queries.

3) Embedding/Referencing: Use 3 criterias
-> Relationship type: If the related data is smaller in size then can be stored together(embedding). However if its very large then should be normalized.
-> Data Access patterns: Analyse the read:write ratio. If the data is mostly going to be read, embedding will help reduce querying times drastically. However, data thats gonna be having frequesnt updates should be referenced and not embedded.
-> Data Closeness: Closeness in the data relations, will they be needed together or would they be required to be accessed on their own as well.

4) Types of Referencing: Upon Choosing to reference relationships while data modelling, 3 types of referencings are possible:
-> Parent: Child references parent, parent is unaware of no. of children. Useful when child documents are unpredictable and grow to a huge amount.
-> Child: Parent holds reference to all children, useful when children are few, and would probably needed only while accessing the parent doument.
-> Two-way: Useful for many:many relationships. Both doucments arent quite closely coupled and quite independent.

Referencing can be done by specifying the field in Schema with a type of mongoose.Schema.ObjectId. This helps mongoose recognise that the field takes a document's id. Also specify the ref attribute with the collection to look in.